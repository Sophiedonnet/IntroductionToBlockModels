# optimal number of blocks / cluster
Q = which.max(sbm.tree$ICL)
Q
Q
# Extract parameters
paramEstimSBMPoisson <- extractParamBM(sbm.tree,Q)
paramEstimSBMPoisson$pi
paramEstimSBMPoisson$lambda
# rearrange the matrix followwing blocks
plotMatrix(tree,'tree','tree', fileNameSave = NULL, clustering = list(row = paramEstimSBMPoisson$Z))
# macropscopic view of the network
G <- graph_from_adjacency_matrix(paramEstimSBMPoisson$lambda, mode = c("undirected"), weighted = TRUE, diag = TRUE)
plot.igraph(G,vertex.size = paramEstimSBMPoisson$pi * 200,edge.width = abs(E(G)$weight) / 2,vertex.color = 1:Q,layout = layout_nicely)
lapply(1:Q,function(q){tree_list[paramEstimSBMPoisson$Z == q]})
# Compare clustering with alluvial plots
A <- as.data.frame(table(paramEstimSBM$Z,paramEstimSBMPoisson$Z))
colnames(A) = c('SBM Bern',"SBM Poisson","Freq")
w   <- which(A$Freq != 0)
A <- A[w,]
alluvial(A[,c(1,2)],freq = A$Freq)
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
ListVar
# rearrange the matrix followwing blocks
plotMatrix(tree,'tree','tree', fileNameSave = NULL, clustering = list(row = paramEstimSBMPoisson$Z))
# macropscopic view of the network
G <- graph_from_adjacency_matrix(paramEstimSBMPoisson$lambda, mode = c("undirected"), weighted = TRUE, diag = TRUE)
plot.igraph(G,vertex.size = paramEstimSBMPoisson$pi * 200,edge.width = abs(E(G)$weight) / 2,vertex.color = 1:Q,layout = layout_nicely)
lapply(1:Q,function(q){tree_list[paramEstimSBMPoisson$Z == q]})
# Compare clustering with alluvial plots
A <- as.data.frame(table(paramEstimSBM$Z,paramEstimSBMPoisson$Z))
colnames(A) = c('SBM Bern',"SBM Poisson","Freq")
w   <- which(A$Freq != 0)
A <- A[w,]
alluvial(A[,c(1,2)],freq = A$Freq)
if (!exists("sbm.cov")) {
sbm.cov <- BM_poisson_covariates("SBM",tree, ListVar)
sbm.cov$estimate()
}
# optimal number of blocks / cluster
Q = which.max(sbm.cov$ICL)
Q
# Extract parameters
paramEstimSBMPoissonCov <- extractParamBM(sbm.cov,Q)
paramEstimSBMPoissonCov$pi
paramEstimSBMPoissonCov$lambda
paramEstimSBMPoissonCov$Z
paramEstimSBMPoissonCov$beta  # effect of the covariates
# compare clusterings
B <- as.data.frame(table(paramEstimSBM$Z,paramEstimSBMPoisson$Z,paramEstimSBMPoissonCov$Z))
BMobject
####relabeling
res$alpha%*%matrix(res$pi,ncol=1)
res <- list()
if (model == 'bernoulli') {
res$alpha <- BMobject$model_parameters[Q][[1]]$pi
}
if (model == 'poisson') {
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
}
if (model == 'poisson_covariates') {
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$beta <-  BMobject$model_parameters[Q][[1]]$beta
}
if (model == 'bernoulli_covariates') { ### a vérifier???
res$alpha <- BMobject$model_parameters[Q][[1]]$pi
res$beta <-  BMobject$model_parameters[Q][[1]]$beta
}
if ((membership_name == 'SBM') | (membership_name == 'SBM_sym')) {
res$tau <-  BMobject$memberships[[Q]]$Z
res$Z <- apply(res$tau, 1, which.max)
n <- nrow(BMobject$memberships[[Q]]$Z)
res$pi <-  colSums(BMobject$memberships[[Q]]$Z)/n
}
if (membership_name == 'LBM'){
res$tauRow <-  BMobject$memberships[[Q]]$Z1
res$tauCol <-  BMobject$memberships[[Q]]$Z2
res$ZRow <- apply(res$tauRow, 1, which.max)
res$ZCol <- apply(res$tauCol, 1, which.max)
nRow <- nrow(BMobject$memberships[[Q]]$Z1)
nCol <- nrow(BMobject$memberships[[Q]]$Z2)
res$piRow <-  colSums(BMobject$memberships[[Q]]$Z1)/nRow
res$piCol <-  colSums(BMobject$memberships[[Q]]$Z2)/nCol
res$Q <- c(length(res$piRow ),length(res$piCol))
names(res$Q) <- c('QRow','QCol')
}
####relabeling
res$alpha %*% matrix(res$pi,ncol=1)
membership_name == 'SBM'
membership_name == 'SBM_sym'
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing == TRUE)
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
res$pi <- res$pi[o];
res$pi
res$alpha
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
res$pi <- res$pi[o];
res$pi
res$alpha
res$tau <-  BMobject$memberships[[Q]]$Z
res$Z <- apply(res$tau, 1, which.max)
n <- nrow(BMobject$memberships[[Q]]$Z)
res$pi <-  colSums(BMobject$memberships[[Q]]$Z)/n
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
res$pi <- res$pi[o];
res$alpha <- res$alpha[o,o];
res$pi
res$alpha <- res$alpha[o,o];
res$alpha
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
res$tau <-  BMobject$memberships[[Q]]$Z
res$Z <- apply(res$tau, 1, which.max)
n <- nrow(BMobject$memberships[[Q]]$Z)
res$pi <-  colSums(BMobject$memberships[[Q]]$Z)/n
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
res$alpha %*% matrix(res$pi,ncol = 1)
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
res$pi
res$pi <- res$pi[o];
res$pi
res$alpha <- res$alpha[o,o];
res$alpha
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
res$pi <- res$pi[o];
res$alpha <- res$alpha[o,o];
res$Z
model <- BMobject$model_name
membership_name <-  BMobject$membership_name
res <- list()
if (model == 'bernoulli') {
res$alpha <- BMobject$model_parameters[Q][[1]]$pi
}
if (model == 'poisson') {
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
}
if (model == 'gaussian') {
res$alpha <- BMobject$model_parameters[Q][[1]]$mu
}
?BM_bernoulli_multiplex
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
res$tau <-  BMobject$memberships[[Q]]$Z
res$Z <- apply(res$tau, 1, which.max)
n <- nrow(BMobject$memberships[[Q]]$Z)
res$pi <-  colSums(BMobject$memberships[[Q]]$Z)/n
res$pi
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
res_o <- res;
res_o$pi <- res$pi[o];
res_o$alpha <- res$alpha[o,o];
o <- order(res_o$alpha %*% matrix(res_o$pi,ncol = 1),decreasing = TRUE)
o
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
res$Z
res$Z[o]
o[res$Z]
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o[res$Z]
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
resOrd$tau <- res$tau[,o]
#relabelling
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
resOrd <- res;
resOrd$pi <- res$pi[o];
resOrd$alpha <- res$alpha[o,o];
resOrd$Z <- o[res$Z]
resOrd$tau <- res$tau[,o]
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
rm(list=ls())
load('fungi_tree_data.Rdata')
ls()
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
load('fungi_tree_data.Rdata')
ls()
library(blockmodels)
library(igraph)
library(alluvial)
library(ggplot2)
source('function_for_blockmodels.R')
# data
plotMatrix(Mat = tree_bin,rowFG = 'tree', colFG  = 'tree')
# SBM for bernoulli
if (!exists("sbm.tree_bin")) {
sbm.tree_bin <- BM_bernoulli("SBM_sym",tree_bin)
sbm.tree_bin$estimate()
}
# optimal number of blocks / cluster
Q = which.max(sbm.tree_bin$ICL)
Q
#- extract the estimated parameters
paramEstimSBM <- extractParamBM(sbm.tree_bin,Q)
paramEstimSBM$pi
paramEstimSBM$alpha
paramEstimSBM$Z
#- rearrange the matrix followwing blocks
plotMatrix(tree_bin,'tree','tree', fileNameSave = NULL, clustering = list(row = paramEstimSBM$Z))
#- macropscopic view of the network
G <- graph_from_adjacency_matrix(paramEstimSBM$alpha, mode = c("undirected"), weighted = TRUE, diag = TRUE)
plot.igraph(G,vertex.size = paramEstimSBM$pi*100,edge.width= abs(E(G)$weight)*3,vertex.color = 1:Q, layout = layout_nicely)
#-  composition of the clusters
lapply(1:Q,function(q){tree_list[paramEstimSBM$Z == q]})
# data
plotMatrix(Mat = tree,rowFG = 'tree', colFG  = 'tree')
sbm.tree <- BM_poisson("SBM_sym",tree)
sbm.tree$estimate()
# optimal number of blocks / cluster
Q = which.max(sbm.tree$ICL)
Q
# Extract parameters
paramEstimSBMPoisson <- extractParamBM(sbm.tree,Q)
paramEstimSBMPoisson$pi
paramEstimSBMPoisson$lambda
paramEstimSBMPoisson$Z
# rearrange the matrix followwing blocks
plotMatrix(tree,'tree','tree', fileNameSave = NULL, clustering = list(row = paramEstimSBMPoisson$Z))
BMobject <- sbm.tree
model <- BMobject$model_name
model
membership_name <-  BMobject$membership_name
membership_name
res <- list()
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
res$lambda
res$alpha <- BMobject$model_parameters[Q][[1]]$mu
res$alpha <- BMobject$model_parameters[Q][[1]]$pi
if (model == 'poisson') {
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
}
res$tau <-  BMobject$memberships[[Q]]$Z
res$Z <- apply(res$tau, 1, which.max)
n <- nrow(BMobject$memberships[[Q]]$Z)
res$pi <-  colSums(BMobject$memberships[[Q]]$Z)/n
res$tauRow <-  BMobject$memberships[[Q]]$Z1
res$tauCol <-  BMobject$memberships[[Q]]$Z2
oRow <- order(res$alpha %*% matrix(res$piCol,ncol = 1),decreasing = TRUE)
oRow <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
#reordering clusters
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
res$alpha %*% matrix(res$pi,ncol = 1)
#reordering clusters
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
resOrd <- res;
resOrd$pi <- res$pi[o];
resOrd$alpha <- res$alpha[o,o];
resOrd$Z <- o[res$Z]
resOrd$tau <- res$tau[,o]
res <- resOrd
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
# optimal number of blocks / cluster
Q = which.max(sbm.tree$ICL)
Q
# Extract parameters
paramEstimSBMPoisson <- extractParamBM(sbm.tree,Q)
paramEstimSBMPoisson$pi
paramEstimSBMPoisson$lambda
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
model == "poisson"
o <- order(res$lambda) %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o <- order(res$lambda %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
resOrd <- res;
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
resOrd$pi <- res$pi[o];
resOrd$alpha <- res$alpha[o,o];
resOrd$Z <- o[res$Z]
resOrd$tau <- res$tau[,o]
res <- resOrd
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
o <- 1:length(res$pi)
o
if ((model == "bernoulli) | (model == 'gaussian')){
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
}
#reordering clusters
resOrd <- res;
resOrd$pi <- res$pi[o];
resOrd$alpha <- res$alpha[o,o];
resOrd$Z <- o[res$Z]
resOrd$tau <- res$tau[,o]
res <- resOrd
}
if (membership_name == 'LBM'){
res$tauRow <-  BMobject$memberships[[Q]]$Z1
res$tauCol <-  BMobject$memberships[[Q]]$Z2
res$ZRow <- apply(res$tauRow, 1, which.max)
res$ZCol <- apply(res$tauCol, 1, which.max)
nRow <- nrow(BMobject$memberships[[Q]]$Z1)
nCol <- nrow(BMobject$memberships[[Q]]$Z2)
res$piRow <-  colSums(BMobject$memberships[[Q]]$Z1)/nRow
res$piCol <-  colSums(BMobject$memberships[[Q]]$Z2)/nCol
res$Q <- c(length(res$piRow ),length(res$piCol))
names(res$Q) <- c('QRow','QCol')
# oRow <- order(res$alpha %*% matrix(res$piCol,ncol = 1),decreasing = TRUE)
# resOrd <- res;
# resOrd$pi <- res$pi[o];
# resOrd$alpha <- res$alpha[o,o];
# resOrd$Z <- o[res$Z]
# resOrd$tau <- res$tau[,o]
}
return(res)
}
################################ Plot the BlockModel Network
plotNetBM = function(BMobject,Q){
membership_name <-  BMobject$membership_name
a <- extractParamBM(BMobject,Q)$alpha
b <- extractParamBM(BMobject,Q)$pi
c <- extractParamBM(BMobject,Q)$piRow
d <- extractParamBM(BMobject,Q)$piCol
if (membership_name == 'SBM_sym') {
G <- graph_from_adjacency_matrix(a, mode = c("undirected"), weighted = TRUE, diag = TRUE)
plot.igraph(G,vertex.size=b*100,edge.width = sqrt(abs(E(G)$weight)),vertex.color=1:Q, layout=layout_nicely)
# vertex.label=""
}
if (membership_name == 'SBM') {
G <- graph_from_adjacency_matrix(a, mode = c("directed"), weighted = TRUE, diag = TRUE)
plot.igraph(G,vertex.size=b*100,edge.width = sqrt(abs(E(G)$weight)),vertex.color = 1:Q, layout=layout_nicely)
# vertex.label=""
}
if (membership_name == 'LBM'){
G <- graph_from_incidence_matrix(a, weighted = TRUE)
plot(G,vertex.size=c(c*100, d*100), vertex.shape=c("circle", "square")[V(G)$type +1],
edge.width=abs(E(G)$weight*2),vertex.color=1:Q, layout=layout.bipartite)
}
#return(g)
}
#vertex.size=c*100, vertex.size2=d*100,
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
o <- 1:length(res$pi)
if (model == "poisson"){
o <- order(res$lambda %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
if ((model == "bernoulli") | (model == 'gaussian')){
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
}
o <- 1:length(res$pi)
if (model == "poisson"){
o <- order(res$lambda %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
if ((model == "bernoulli") | (model == 'gaussian')){
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
}
}}}
o <- 1:length(res$pi)
if (model == "poisson"){
o <- order(res$lambda %*% matrix(res$pi,ncol = 1),decreasing = TRUE)}
if ((model == "bernoulli") | (model == 'gaussian')){
o <- order(res$alpha %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
}
resOrd <- res;
resOrd$pi <- res$pi[o];
resOrd$alpha <- res$alpha[o,o];
resOrd$Z <- o[res$Z]
resOrd$tau <- res$tau[,o]
res <- resOrd
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
# Extract parameters
paramEstimSBMPoisson <- extractParamBM(sbm.tree,Q)
paramEstimSBMPoisson$pi
paramEstimSBMPoisson$lambda
paramEstimSBMPoisson$Z
# rearrange the matrix followwing blocks
plotMatrix(tree,'tree','tree', fileNameSave = NULL, clustering = list(row = paramEstimSBMPoisson$Z))
model == "poisson"
res$lambda
res$lambda %*% matrix(res$pi,ncol = 1)
model <- BMobject$model_name
membership_name <-  BMobject$membership_name
res <- list()
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
res$tau <-  BMobject$memberships[[Q]]$Z
res$Z <- apply(res$tau, 1, which.max)
n <- nrow(BMobject$memberships[[Q]]$Z)
res$pi <-  colSums(BMobject$memberships[[Q]]$Z)/n
res$pi
o <- 1:length(res$pi)
model == "poisson"
res$lambda
res$lambda %*% matrix(res$pi,ncol = 1)
o <- order(res$lambda %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
o
resOrd <- res;
resOrd$pi <- res$pi[o];
resOrd$pi
resOrd$pi <- res$pi[o];
resOrd$pi
if (model == "poisson") {
o <- order(res$lambda %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
}
o
resOrd <- res;
res$pi
res$pi[o]
o
model <- BMobject$model_name
membership_name <-  BMobject$membership_name
res <- list()
if (model == 'bernoulli') {
res$alpha <- BMobject$model_parameters[Q][[1]]$pi
}
if (model == 'poisson') {
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
}
if (model == 'gaussian') {
res$alpha <- BMobject$model_parameters[Q][[1]]$mu
}
if (model == 'bernoulli_multiplex') {
res$alpha <- BMobject$model_parameters[Q][[1]]$pi
}
if (model == 'poisson_covariates') {
res$lambda <- BMobject$model_parameters[Q][[1]]$lambda
res$alpha <- log(BMobject$model_parameters[Q][[1]]$lambda)
res$beta <-  BMobject$model_parameters[Q][[1]]$beta
}
if (model == 'bernoulli_covariates') { ### a vérifier???
res$alpha <- BMobject$model_parameters[Q][[1]]$mu
res$beta <-  BMobject$model_parameters[Q][[1]]$beta
}
if (model == 'gaussian_covariates') { ### a vérifier???
res$alpha <- BMobject$model_parameters[Q][[1]]$pi
res$beta <-  BMobject$model_parameters[Q][[1]]$beta
}
res$tau <-  BMobject$memberships[[Q]]$Z
res$Z <- apply(res$tau, 1, which.max)
n <- nrow(BMobject$memberships[[Q]]$Z)
res$pi <-  colSums(BMobject$memberships[[Q]]$Z)/n
res$pi
o <- 1:length(res$pi)
o
if (model == "poisson") {
o <- order(res$lambda %*% matrix(res$pi,ncol = 1),decreasing = TRUE)
}
o
resOrd <- res;
resOrd$pi <- res$pi[o];
resOrd$pi
res$pi
res$pi[o]
o
res$pi
o
resOrd$pi <- res$pi[o];
res$pi
res$pi[o]
resOrd$alpha <- res$alpha[o,o];
resOrd$Z <- o[res$Z]
resOrd$tau <- res$tau[,o]
res <- resOrd
if(model == 'poisson'){resOrd$lambda <- res$lambda[o,o]}
resOrd$Z <- o[res$Z]
resOrd$tau <- res$tau[,o]
res <- resOrd
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
# rearrange the matrix followwing blocks
plotMatrix(tree,'tree','tree', fileNameSave = NULL, clustering = list(row = paramEstimSBMPoisson$Z))
# optimal number of blocks / cluster
Q = which.max(sbm.tree$ICL)
Q
# Extract parameters
paramEstimSBMPoisson <- extractParamBM(sbm.tree,Q)
paramEstimSBMPoisson
paramEstimSBMPoisson$pi
paramEstimSBMPoisson$lambda
paramEstimSBMPoisson$lambda%*%matrix(paramEstimSBMPoisson$pi,ncol=1)
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
source('C:/Users/Donnet/Dropbox/Formation_NGB/materiel_formation_BM/function_for_blockmodels.R', encoding = 'UTF-8')
